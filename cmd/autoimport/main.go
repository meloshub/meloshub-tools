package main

import (
	"bytes"
	"flag"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

// 生成all.go的模板
const allGoTemplate = `// Code generated by meloshub-adapters/tools/autoimport. DO NOT EDIT.

package {{.PackageName}}

import (
	// This list is auto-generated.
{{range .ImportPaths}}	_ "{{.}}"
{{end}})
`

func main() {
	outputFile := flag.String("output", "all/all.go", "Path to the output all.go file")
	pkgName := flag.String("pkg", "all", "The package name for the generated file")
	modulePath := flag.String("module", "github.com/meloshub/meloshub-adapters", "The base module path for imports")
	flag.Parse()

	rootDir, err := os.Getwd()
	if err != nil {
		log.Fatalf("Error getting working directory: %v", err)
	}

	log.Println("Scanning for adapter packages in:", rootDir)

	var importPaths []string

	// 读取根目录下的所有条目
	entries, err := os.ReadDir(rootDir)
	if err != nil {
		log.Fatalf("Error reading root directory: %v", err)
	}

	for _, entry := range entries {
		if !entry.IsDir() || strings.HasPrefix(entry.Name(), ".") || entry.Name() == "tools" || entry.Name() == *pkgName {
			continue
		}

		dirName := entry.Name()
		dirPath := filepath.Join(rootDir, dirName)

		if !isGoPackage(dirPath) {
			log.Printf("Skipping directory '%s' as it does not contain any .go files.", dirName)
			continue
		}

		// 构建完整的导入路径
		fullImportPath := filepath.ToSlash(filepath.Join(*modulePath, dirName))
		importPaths = append(importPaths, fullImportPath)
		log.Printf("Found adapter package: %s", fullImportPath)
	}

	// 排序
	sort.Strings(importPaths)

	// 使用模板生成文件内容
	tmpl, err := template.New("all.go").Parse(allGoTemplate)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}

	data := struct {
		PackageName string
		ImportPaths []string
	}{
		PackageName: *pkgName,
		ImportPaths: importPaths,
	}

	var buffer bytes.Buffer
	if err := tmpl.Execute(&buffer, data); err != nil {
		log.Fatalf("Failed to execute template: %v", err)
	}

	// 保证输出目录存在
	if err := os.MkdirAll(filepath.Dir(*outputFile), 0755); err != nil {
		log.Fatalf("Failed to create output directory: %v", err)
	}

	// 生成内容写入文件
	if err := os.WriteFile(*outputFile, buffer.Bytes(), 0644); err != nil {
		log.Fatalf("Failed to write to %s: %v", *outputFile, err)
	}

	log.Printf("Successfully generated %s with %d adapter imports.", *outputFile, len(importPaths))
}

// isGoPackage 检查一个目录是否包含至少一个 .go 文件
func isGoPackage(dirPath string) bool {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dirPath, func(fi os.FileInfo) bool {
		return !strings.HasSuffix(fi.Name(), "_test.go")
	}, parser.PackageClauseOnly)

	if err != nil {
		return false
	}

	return len(pkgs) > 0
}
